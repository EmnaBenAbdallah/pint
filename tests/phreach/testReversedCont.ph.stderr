# testReversedCont.ph: 3 actions
# testing reachability of z_2 from state [a_1]
- computing aBS(z 0 2)... [ { a 0 } ]
- computing aBS(a 1 0)... [ { z 0 } ]
- computing aBS(z 0 0)... [ {  } ]
 - Sol(a 1 0) = [ { z 0 } ]
 - Sol(z 0 0) = [ {  } ]
 - Sol(z 0 2) = [ { a 0 } ]
 - Req(a 0) = [ a 1 0 ]
 - Req(z 0) = [ z 0 0 ]
 - Req(z 2) = [ z 0 2 ]
 - procs = { a 0, z 0, z 2 }
 - objs = { a 1 0, z 0 0, z 0 2 }

+ over-approximation (1) success
# handling concretion
- continuity saturation...
tBS: exact (expensive) computation.
- computing BS(z 0 2)... [ { z_0->z_0 1, a_0->z_1 2 } ]
reverse continuity from a 0: z 1 0
- new objectives [ z 1 0 ]
- computing aBS(z 1 0)... [  ]
 - Sol(a 1 0) = [ { z 0 } ]
 - Sol(z 0 0) = [ {  } ]
 - Sol(z 0 2) = [ { a 0 } ]
 - Req(a 0) = [ a 1 0 ]
 - Req(z 0) = [ z 1 0; z 0 0 ]
 - Req(z 2) = [ z 0 2 ]
 - Cont(a 1 0) = {  }
 - Cont(z 0 0) = {  }
 - Cont(z 0 2) = {  }
 - procs = { a 0, z 0, z 2 }
 - objs = { a 1 0, z 0 0, z 0 2 }

- new objectives [  ]
# continue concretizing
# aborting concretion
